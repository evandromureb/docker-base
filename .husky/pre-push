#!/usr/bin/env sh
set -e

# Configura√ß√£o
TIMEOUT_SECONDS=300  # 5 minutos de timeout
CACHE_DIR=".husky/cache"
CONFIG_FILE=".husky/pre-push.config"
AUDIT_LOG=".husky/audit.log"

# Cores para feedback visual
NC='\033[0m'         # Sem cor
BBlue='\033[1;34m'   # Azul negrito
BRed='\033[1;31m'    # Vermelho negrito
BGreen='\033[1;32m'  # Verde negrito
BYellow='\033[1;33m' # Amarelo negrito
BCyan='\033[1;36m'   # Ciano negrito
BWhite='\033[1;37m'  # Branco negrito

# Lista de comandos permitidos (whitelist)
ALLOWED_COMMANDS=(
    "npx"
    "php"
    "composer"
    "git"
    "node"
    "npm"
    "yarn"
    "pint"
    "phpstan"
    "php-cs-fixer"
    "security-checker"
    "artisan"
    "test"
    "lint-staged"
)

# Lista de caracteres perigosos
DANGEROUS_CHARS=';&|`$(){}[]<>\\'

# Fun√ß√£o para sanitizar strings (prote√ß√£o contra inje√ß√£o)
sanitize_string() {
    local input="$1"
    # Remove caracteres perigosos
    echo "$input" | sed 's/[;&|`$(){}[\]<>]/_/g' | sed 's/\.\./_/g'
}

# Fun√ß√£o para validar caminhos de arquivo
validate_file_path() {
    local path="$1"
    local base_dir="$2"
    
    # Verificar se o caminho cont√©m path traversal
    if echo "$path" | grep -q "\.\."; then
        return 1
    fi
    
    # Verificar se o caminho est√° dentro do diret√≥rio base
    local real_path=$(realpath "$path" 2>/dev/null || echo "$path")
    local real_base=$(realpath "$base_dir" 2>/dev/null || echo "$base_dir")
    
    if [[ "$real_path" == "$real_base"* ]]; then
        return 0
    fi
    
    return 1
}

# Fun√ß√£o para validar e sanitizar cache key
validate_cache_key() {
    local cache_key="$1"
    
    # Permitir apenas caracteres seguros
    if echo "$cache_key" | grep -qE '^[a-zA-Z0-9_-]+$'; then
        echo "$cache_key"
    else
        # Sanitizar se n√£o for v√°lido
        echo "$cache_key" | sed 's/[^a-zA-Z0-9_-]/_/g'
    fi
}

# Fun√ß√£o para validar comando (whitelist)
validate_command() {
    local command="$1"
    local base_cmd=$(echo "$command" | awk '{print $1}')
    
    # Verificar se o comando base est√° na whitelist
    for allowed in "${ALLOWED_COMMANDS[@]}"; do
        if [[ "$base_cmd" == "$allowed" ]]; then
            return 0
        fi
    done
    
    return 1
}

# Fun√ß√£o para logging de auditoria
audit_log() {
    local action="$1"
    local details="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local user=$(whoami 2>/dev/null || echo "unknown")
    local hostname=$(hostname 2>/dev/null || echo "unknown")
    
    echo "[$timestamp] USER:$user HOST:$hostname ACTION:$action DETAILS:$details" >> "$AUDIT_LOG"
}

# Fun√ß√£o para executar comando com valida√ß√£o de seguran√ßa
run_command_safe() {
    local description="$1"
    local command="$2"
    local skip_on_failure="${3:-false}"
    local timeout="${4:-$TIMEOUT_SECONDS}"
    
    # Log de auditoria
    audit_log "COMMAND_EXECUTION" "Description: $description, Command: $command"
    
    # Validar se o comando cont√©m caracteres perigosos
    if echo "$command" | grep -qE '[;&|`$(){}[\]<>\\]'; then
        log "ERROR" "‚ùå Comando rejeitado por seguran√ßa: $command"
        audit_log "SECURITY_VIOLATION" "Dangerous characters in command: $command"
        return 1
    fi
    
    # Validar comando na whitelist
    if ! validate_command "$command"; then
        log "ERROR" "‚ùå Comando n√£o autorizado: $command"
        audit_log "SECURITY_VIOLATION" "Unauthorized command: $command"
        return 1
    fi
    
    log "INFO" "üöÄ Executando $description..."
    
    # Executar comando com timeout e valida√ß√£o
    if timeout "$timeout" sh -c "$command"; then
        log "SUCCESS" "‚úÖ $description conclu√≠do com sucesso"
        audit_log "COMMAND_SUCCESS" "Description: $description"
        return 0
    else
        local exit_code=$?
        if [ $exit_code -eq 124 ]; then
            log "ERROR" "‚è∞ $description excedeu o timeout de ${timeout}s"
            audit_log "COMMAND_TIMEOUT" "Description: $description, Timeout: ${timeout}s"
        else
            log "ERROR" "‚ùå $description falhou com c√≥digo de sa√≠da: $exit_code"
            audit_log "COMMAND_FAILURE" "Description: $description, Exit code: $exit_code"
        fi
        
        if [ "$skip_on_failure" = "true" ]; then
            log "WARN" "‚ö†Ô∏è $description falhou, continuando..."
            return 1
        else
            log "ERROR" "üõë Falha em $description. Por favor corrija os erros antes de continuar."
            exit 1
        fi
    fi
}

# Fun√ß√£o para logging com timestamp
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%H:%M:%S')
    echo -e "[${timestamp}] ${level}: ${message}"
}

# Fun√ß√£o para verificar se uma ferramenta est√° dispon√≠vel
check_tool() {
    local tool_name="$1"
    local tool_path="$2"
    
    # Validar caminho da ferramenta
    if ! validate_file_path "$tool_path" "."; then
        log "ERROR" "‚ùå Caminho da ferramenta inv√°lido: $tool_path"
        audit_log "SECURITY_VIOLATION" "Invalid tool path: $tool_path"
        return 1
    fi
    
    if [ -f "$tool_path" ]; then
        log "INFO" "‚úÖ $tool_name encontrado em: $tool_path"
        return 0
    else
        log "WARN" "‚ö†Ô∏è $tool_name n√£o encontrado em: $tool_path"
        return 1
    fi
}

# Fun√ß√£o para executar comando com timeout e tratamento de erro (DEPRECATED - usar run_command_safe)
run_command() {
    log "WARN" "‚ö†Ô∏è run_command est√° deprecated. Use run_command_safe para melhor seguran√ßa."
    run_command_safe "$@"
}

# Fun√ß√£o para criar cache directory
setup_cache() {
    # Validar e criar diret√≥rio de cache de forma segura
    if validate_file_path "$CACHE_DIR" "."; then
        mkdir -p "$CACHE_DIR"
        # Definir permiss√µes restritivas
        chmod 700 "$CACHE_DIR" 2>/dev/null || true
        
        # Criar arquivo de auditoria se n√£o existir
        touch "$AUDIT_LOG" 2>/dev/null || true
        chmod 600 "$AUDIT_LOG" 2>/dev/null || true
    else
        log "ERROR" "‚ùå Caminho de cache inv√°lido: $CACHE_DIR"
        exit 1
    fi
}

# Fun√ß√£o para verificar cache
check_cache() {
    local cache_key="$1"
    local sanitized_key=$(validate_cache_key "$cache_key")
    local cache_file="$CACHE_DIR/$sanitized_key"
    
    # Validar caminho do arquivo de cache
    if ! validate_file_path "$cache_file" "$CACHE_DIR"; then
        log "ERROR" "‚ùå Caminho de cache inv√°lido: $cache_file"
        return 1
    fi
    
    if [ -f "$cache_file" ]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file")))
        # Cache v√°lido por 1 hora
        if [ $cache_age -lt 3600 ]; then
            return 0
        fi
    fi
    return 1
}

# Fun√ß√£o para atualizar cache
update_cache() {
    local cache_key="$1"
    local sanitized_key=$(validate_cache_key "$cache_key")
    local cache_file="$CACHE_DIR/$sanitized_key"
    
    # Validar caminho do arquivo de cache
    if ! validate_file_path "$cache_file" "$CACHE_DIR"; then
        log "ERROR" "‚ùå Caminho de cache inv√°lido: $cache_file"
        return 1
    fi
    
    touch "$cache_file"
    # Definir permiss√µes restritivas
    chmod 600 "$cache_file" 2>/dev/null || true
}

# Fun√ß√£o para carregar configura√ß√£o de forma segura
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Validar caminho do arquivo de configura√ß√£o
        if ! validate_file_path "$CONFIG_FILE" "."; then
            log "ERROR" "‚ùå Caminho de configura√ß√£o inv√°lido: $CONFIG_FILE"
            exit 1
        fi
        
        log "INFO" "üìã Carregando configura√ß√£o de $CONFIG_FILE"
        
        # Carregar configura√ß√£o de forma segura
        while IFS='=' read -r key value; do
            # Ignorar coment√°rios e linhas vazias
            [[ $key =~ ^[[:space:]]*# ]] && continue
            [[ -z $key ]] && continue
            
            # Validar nome da vari√°vel
            if [[ $key =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
                export "$key=$value"
            else
                log "WARN" "‚ö†Ô∏è Vari√°vel de configura√ß√£o inv√°lida ignorada: $key"
                audit_log "CONFIG_WARNING" "Invalid config variable: $key"
            fi
        done < "$CONFIG_FILE"
    else
        log "INFO" "üìã Usando configura√ß√£o padr√£o"
        # Configura√ß√µes padr√£o
        ENABLE_LINT_STAGED=true
        ENABLE_PHPSTAN=true
        ENABLE_TESTS=true
        ENABLE_PINT=true
        ENABLE_CS_FIXER=true
        ENABLE_SECURITY_CHECK=true
        ENABLE_CACHE=true
    fi
}

# Fun√ß√£o para validar arquivos staged
validate_staged_files() {
    local staged_files="$1"
    
    echo "$staged_files" | while read file; do
        # Validar se o arquivo n√£o cont√©m path traversal
        if echo "$file" | grep -q "\.\."; then
            log "ERROR" "‚ùå Arquivo com path traversal detectado: $file"
            audit_log "SECURITY_VIOLATION" "Path traversal detected: $file"
            return 1
        fi
        
        # Validar se o arquivo existe e est√° dentro do reposit√≥rio
        if [ -f "$file" ]; then
            if ! validate_file_path "$file" "."; then
                log "ERROR" "‚ùå Arquivo fora do reposit√≥rio detectado: $file"
                audit_log "SECURITY_VIOLATION" "File outside repository: $file"
                return 1
            fi
        else
            log "WARN" "‚ö†Ô∏è Arquivo n√£o encontrado: $file"
        fi
    done
    
    return 0
}

# Fun√ß√£o para mostrar resumo de arquivos
show_staged_files() {
    local staged_files=$(git diff --cached --name-only)
    local count=$(echo "$staged_files" | wc -l)
    
    if [ "$count" -gt 0 ]; then
        # Validar arquivos staged antes de processar
        if ! validate_staged_files "$staged_files"; then
            log "ERROR" "‚ùå Arquivos staged inv√°lidos detectados"
            exit 1
        fi
        
        log "INFO" "üìã Encontrados $count arquivo(s) staged para verifica√ß√£o:"
        echo "$staged_files" | while read file; do
            echo -e "  üìÑ $file"
        done
    else
        log "INFO" "üìã Nenhum arquivo staged encontrado"
        log "INFO" "üí° Dica: Use 'git add <arquivos>' para adicionar arquivos ao staging"
        return 1
    fi
}

# Fun√ß√£o para verificar depend√™ncias
check_dependencies() {
    log "INFO" "üîç Verificando depend√™ncias..."
    
    # Verificar depend√™ncias PHP
    if [ -f "./composer.json" ]; then
        if [ ! -d "./vendor" ]; then
            log "ERROR" "‚ùå Depend√™ncias PHP n√£o instaladas"
            log "INFO" "üí° Execute: composer install"
            exit 1
        fi
        log "SUCCESS" "‚úÖ Depend√™ncias PHP verificadas"
    fi
    
    # Verificar depend√™ncias Node.js
    if [ -f "./package.json" ]; then
        if [ ! -d "./node_modules" ]; then
            log "WARN" "‚ö†Ô∏è Depend√™ncias Node.js n√£o instaladas"
            log "INFO" "üí° Execute: npm install"
        else
            log "SUCCESS" "‚úÖ Depend√™ncias Node.js verificadas"
        fi
    fi
}

# Fun√ß√£o principal de verifica√ß√µes
run_checks() {
    local staged_files=$(git diff --cached --name-only)
    
    if [ -z "$staged_files" ]; then
        log "INFO" "üìã Nenhum arquivo staged para verifica√ß√£o"
        log "INFO" "üí° Hook executado com sucesso - n√£o h√° arquivos para verificar"
        return 0
    fi
    
    show_staged_files
    
    # 1. Executar lint-staged
    if [ "$ENABLE_LINT_STAGED" = "true" ] && check_tool "lint-staged" "./node_modules/.bin/lint-staged"; then
        if check_cache "lint-staged"; then
            log "INFO" "‚ö° Usando cache para lint-staged"
        else
            run_command_safe "lint-staged" "npx lint-staged" false 120
            [ "$ENABLE_CACHE" = "true" ] && update_cache "lint-staged"
        fi
    else
        log "WARN" "‚ö†Ô∏è lint-staged n√£o dispon√≠vel ou desabilitado"
    fi
    
    # 2. Verificar depend√™ncias
    check_dependencies
    
    # 3. Executar PHPStan
    if [ "$ENABLE_PHPSTAN" = "true" ] && check_tool "PHPStan" "./vendor/bin/phpstan"; then
        local php_files=$(echo "$staged_files" | grep "\.php$" | tr '\n' ' ')
        
        if [ -n "$php_files" ]; then
            log "INFO" "üìÑ Analisando arquivos PHP com PHPStan..."
            echo "$php_files" | tr ' ' '\n' | while read file; do
                echo -e "  üìÑ $file"
            done
            
            if check_cache "phpstan"; then
                log "INFO" "‚ö° Usando cache para PHPStan"
            else
                run_command_safe "an√°lise PHPStan" "./vendor/bin/phpstan analyse $php_files" false 180
                [ "$ENABLE_CACHE" = "true" ] && update_cache "phpstan"
            fi
        else
            log "INFO" "üìÑ Nenhum arquivo PHP alterado para an√°lise"
        fi
    fi
    
    # 4. Executar testes
    if [ "$ENABLE_TESTS" = "true" ] && check_tool "Artisan" "./artisan"; then
        if [ -d "./tests" ] || [ -d "./tests/Unit" ] || [ -d "./tests/Feature" ]; then
            if check_cache "tests"; then
                log "INFO" "‚ö° Usando cache para testes"
            else
                if php artisan test --help | grep -q "parallel"; then
                    run_command_safe "testes em paralelo" "php artisan test --parallel" false 240
                else
                    run_command_safe "testes" "php artisan test" false 240
                fi
                [ "$ENABLE_CACHE" = "true" ] && update_cache "tests"
            fi
        else
            log "WARN" "‚ö†Ô∏è Nenhum teste encontrado"
        fi
    fi
    
    # 5. Formatar arquivos PHP com Laravel Pint
    if [ "$ENABLE_PINT" = "true" ] && check_tool "Laravel Pint" "./vendor/bin/pint"; then
        local staged_php_files=$(echo "$staged_files" | grep "\.php$" | tr '\n' ' ')
        
        if [ -n "$staged_php_files" ]; then
            log "INFO" "üé® Formatando arquivos PHP com Laravel Pint..."
            echo "$staged_php_files" | tr ' ' '\n' | while read file; do
                echo -e "  üé® $file"
            done
            
            if echo "$staged_php_files" | xargs ./vendor/bin/pint; then
                echo "$staged_php_files" | xargs git add
                log "SUCCESS" "‚úÖ Arquivos formatados com Laravel Pint"
            else
                log "ERROR" "‚ùå Erro na formata√ß√£o com Laravel Pint"
                exit 1
            fi
        else
            log "INFO" "üé® Nenhum arquivo PHP alterado para formatar"
        fi
    fi
    
    # 6. PHP CS Fixer (opcional)
    if [ "$ENABLE_CS_FIXER" = "true" ] && check_tool "PHP CS Fixer" "./vendor/bin/php-cs-fixer"; then
        local staged_php_files=$(echo "$staged_files" | grep "\.php$" | tr '\n' ' ')
        
        if [ -n "$staged_php_files" ]; then
            run_command_safe "verifica√ß√£o PHP CS Fixer" "echo \"$staged_php_files\" | xargs ./vendor/bin/php-cs-fixer fix --dry-run --diff" true 60
        fi
    fi
    
    # 7. Verifica√ß√£o de seguran√ßa
    if [ "$ENABLE_SECURITY_CHECK" = "true" ]; then
        # Verificar vulnerabilidades no composer.lock
        if check_tool "PHP Security Checker" "./vendor/bin/security-checker"; then
            run_command_safe "verifica√ß√£o de seguran√ßa" "./vendor/bin/security-checker security:check composer.lock" true 60
        fi
        
        # Verificar arquivos PHP por vulnerabilidades comuns
        local php_files=$(echo "$staged_files" | grep "\.php$" | tr '\n' ' ')
        if [ -n "$php_files" ]; then
            log "INFO" "üîí Verificando vulnerabilidades de seguran√ßa em arquivos PHP..."
            
            # Verificar por fun√ß√µes perigosas
            echo "$php_files" | tr ' ' '\n' | while read file; do
                if [ -f "$file" ]; then
                    # Verificar fun√ß√µes perigosas
                    local dangerous_functions=$(grep -n "eval\|exec\|system\|shell_exec\|passthru\|popen\|proc_open" "$file" 2>/dev/null || true)
                    if [ -n "$dangerous_functions" ]; then
                        log "WARN" "‚ö†Ô∏è Fun√ß√µes perigosas encontradas em $file:"
                        echo "$dangerous_functions" | while read line; do
                            echo -e "    ‚ö†Ô∏è $line"
                        done
                        audit_log "SECURITY_WARNING" "Dangerous functions in $file"
                    fi
                    
                    # Verificar por SQL injection patterns
                    local sql_patterns=$(grep -n "SELECT.*\$_GET\|SELECT.*\$_POST\|SELECT.*\$_REQUEST" "$file" 2>/dev/null || true)
                    if [ -n "$sql_patterns" ]; then
                        log "WARN" "‚ö†Ô∏è Poss√≠vel SQL injection detectado em $file:"
                        echo "$sql_patterns" | while read line; do
                            echo -e "    ‚ö†Ô∏è $line"
                        done
                        audit_log "SECURITY_WARNING" "Possible SQL injection in $file"
                    fi
                fi
            done
        fi
        
        # Verificar por credenciais expostas
        local sensitive_files=$(echo "$staged_files" | grep -E "\.(env|config|ini|json|xml|yml|yaml)$" | tr '\n' ' ')
        if [ -n "$sensitive_files" ]; then
            log "INFO" "üîí Verificando por credenciais expostas..."
            echo "$sensitive_files" | tr ' ' '\n' | while read file; do
                if [ -f "$file" ]; then
                    # Verificar por padr√µes de credenciais
                    local credentials=$(grep -n -i "password\|secret\|key\|token\|api_key" "$file" 2>/dev/null || true)
                    if [ -n "$credentials" ]; then
                        log "WARN" "‚ö†Ô∏è Poss√≠veis credenciais encontradas em $file:"
                        echo "$credentials" | while read line; do
                            echo -e "    ‚ö†Ô∏è $line"
                        done
                        audit_log "SECURITY_WARNING" "Possible credentials in $file"
                    fi
                fi
            done
        fi
    fi
}

# Fun√ß√£o para mostrar resumo final
show_summary() {
    log "SUCCESS" "üéâ Todas as verifica√ß√µes pre-push conclu√≠das com sucesso!"
    echo -e "${BCyan}üìä Resumo das verifica√ß√µes:${NC}"
    echo -e "  ‚úÖ lint-staged (${ENABLE_LINT_STAGED:-true})"
    echo -e "  ‚úÖ Depend√™ncias verificadas"
    echo -e "  ‚úÖ PHPStan (${ENABLE_PHPSTAN:-true})"
    echo -e "  ‚úÖ Testes (${ENABLE_TESTS:-true})"
    echo -e "  ‚úÖ Laravel Pint (${ENABLE_PINT:-true})"
    echo -e "  ‚úÖ PHP CS Fixer (${ENABLE_CS_FIXER:-true})"
    echo -e "  ‚úÖ Verifica√ß√£o de seguran√ßa (${ENABLE_SECURITY_CHECK:-true})"
    echo -e "  ‚úÖ Cache (${ENABLE_CACHE:-true})"
}

# Fun√ß√£o para verificar integridade do reposit√≥rio
check_repository_integrity() {
    log "INFO" "üîç Verificando integridade do reposit√≥rio..."
    
    # Verificar se estamos em um reposit√≥rio Git v√°lido
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log "ERROR" "‚ùå Erro: N√£o estamos em um reposit√≥rio Git"
        exit 1
    fi
    
    # Verificar se o reposit√≥rio n√£o est√° corrompido
    if ! git fsck --no-dangling > /dev/null 2>&1; then
        log "ERROR" "‚ùå Reposit√≥rio Git corrompido detectado"
        exit 1
    fi
    
    # Verificar se h√° commits √≥rf√£os
    local orphan_commits=$(git log --all --grep="^$" --oneline 2>/dev/null | wc -l)
    if [ "$orphan_commits" -gt 0 ]; then
        log "WARN" "‚ö†Ô∏è Encontrados $orphan_commits commit(s) √≥rf√£o(s)"
    fi
    
    # Verificar permiss√µes de arquivos sens√≠veis
    local sensitive_files=(".env" ".env.example" "composer.lock" "package-lock.json")
    for file in "${sensitive_files[@]}"; do
        if [ -f "$file" ]; then
            local perms=$(stat -c %a "$file" 2>/dev/null || echo "000")
            if [ "$perms" != "600" ] && [ "$perms" != "644" ]; then
                log "WARN" "‚ö†Ô∏è Permiss√µes muito abertas em $file: $perms"
                audit_log "SECURITY_WARNING" "Open permissions on $file: $perms"
            fi
        fi
    done
    
    log "SUCCESS" "‚úÖ Integridade do reposit√≥rio verificada"
}

# In√≠cio do script
main() {
    log "INFO" "üöÄ Iniciando verifica√ß√µes pre-push..."
    audit_log "HOOK_START" "Pre-push hook initiated"
    
    # Verificar integridade do reposit√≥rio
    check_repository_integrity
    
    # Configurar cache
    setup_cache
    
    # Carregar configura√ß√£o
    load_config
    
    # Executar verifica√ß√µes
    if run_checks; then
        show_summary
        audit_log "HOOK_SUCCESS" "All checks passed successfully"
        exit 0
    else
        log "ERROR" "‚ùå Algumas verifica√ß√µes falharam"
        audit_log "HOOK_FAILURE" "Some checks failed"
        exit 1
    fi
}

# Executar fun√ß√£o principal
main "$@"
